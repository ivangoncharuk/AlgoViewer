Amazing, it works. Now I would like to change something with the visualization of quicksort. I want the quicksorting visualization to work like this:

Initial Unsorted State: Blue bars to represent the unsorted array.
Pivot Selection: Green for the selected pivot.
Partitioning: Red bars for elements being compared.
Swapping: Briefly use yellow for swapped elements.
Sorted State: Green bars for completely sorted segments.

in your response, limit the explanation of what you're about to do and just make the changes immediately.

There was a previous network error in your response, here are the functions you gave me before it failed, continue this please.

```
def quick_sort(data, low=0, high=None, comparisons=0, swaps=0):
    if high is None:
        high = len(data) - 1

    if low < high:
        pivot_index, comparisons, swaps, partition_steps = partition(
            data, low, high, comparisons, swaps
        )

        # Highlight pivot selection
        yield data, None, high, comparisons, swaps, "pivot_selection"

        for step in partition_steps:
            yield step

        for state in quick_sort(data, low, pivot_index - 1, comparisons, swaps):
            yield state

        for state in quick_sort(data, pivot_index + 1, high, comparisons, swaps):
            yield state
```

```
def partition(data, low, high, comparisons, swaps):
    pivot = data[high]
    i = low - 1
    steps = []

    for j in range(low, high):
        comparisons += 1
        steps.append((data[:], (j, high), high, comparisons, swaps, "compare"))  # Compare action
        if data[j] < pivot:
            i += 1
            data[i], data[j] = data[j], data[i]
            swaps += 1
            steps.append((data[:], (i, j), high, comparisons, swaps, "swap"))  # Swap action

    data[i + 1], data[high] = data[high], data[i + 1]
    swaps += 1
    steps.append((data[:], (i + 1, high), high, comparisons, swaps, "swap"))  # Final swap for pivot
    pivot_index = i + 1

    return pivot_index, comparisons, swaps, steps
```

```
def update_bars(self, data, comparison_indices, max_value, additional_info=None, action=None):
    c_width, c_height = self.winfo_width(), self.winfo_height()
    for i, val in enumerate(data):
        color = "blue"  # Default color for unsorted bars

        if action == "pivot_selection" and i == additional_info:
            color = "green"  # Color for pivot
        elif action == "compare" and i in comparison_indices:
            color = "red"  # Color for comparison
        elif action == "swap" and i in comparison_indices:
            color = "yellow"  # Color for swap
        elif action == "sorted":
            color = "green"  # Color for sorted segments

        self.itemconfig(self.rectangles[i], fill=color)
        self.coords(
            self.rectangles[i],
            *self.calculate_bar_dimensions(
                i, val, len(data), c_width, c_height, max_value
            )
        )
```

Then you cut off when you began to give me this:

Update the Visualization Method:
Update the visualize_quick_sort method in the MainWindow class to pass the action type to update_bars.

```
def visualize_quick_sort(self, speed):
    data = self.current_data
    max_value = max(data)
    self.animation_canvas.create_initial_bars(data, max_value)

    for step, comparison_indices, pivot_index, self.comparisons, self.swaps, action in sorting_algorithms.quick_sort(
        data,
        comparisons=self.comparisons,
        swaps=self.swaps,
    ):
        if self.stop_visualization:
            break
        self.animation_canvas.update_bars(step, comparison_indices, max_value, pivot_index, action)
        self.update_idletasks()
        time.sleep(0.5 / speed)
        self.update_counters(self.comparisons, self.swaps)

    if not self.stop_visualization:
        # Color all bars green to indicate that sorting is complete
        self.animation_canvas.update_bars(data, None, max_value, None, "sorted")
        sidebar_controls.enable_controls(self, True)
        self.play_pause_button.configure(text="Play")
        self.sorting_completed = True
        self.is_visualizing = False
    else:
        self.play_pause_button.configure(text="Play")
        self.is_visualizing = False
```
